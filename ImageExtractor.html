<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="Description" content="Image extractor" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <title>Image Extractor</title>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="#">Navbar</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item">
                    <a class="nav-link" href="RatioCalculator.html">RatioCalculator</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="ImageExtractor.html">Image Extractor</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="ConditionalCalculator.html">Conditional Calculator</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="tabelCalculator.html">Table Calculator</a>
                </li>
        </div>
    </nav>
    <div>
        <img src="./assets/vinaylogo.png" alt="logo" class="logo-style">
    </div>
    <div class="container">

        <div class="row d-flex justify-content-center h-100 flex-column align-items-center">
            <div>
                <h1>Image Extractor</h1>

                <label for="noOfImages">FILE</label>
                <input type="number" id="noOfImages" value="2" required>
                <label for="noOfTimes">CARD</label>
                <input type="number" id="noOfTimes" value="2" required>
                <input class="btn" type="file" id="upload" accept="image/bmp">
                <canvas id="canvas" style="display:none;"></canvas>
                <button type="button" class="btn btn-danger" onClick="window.location.reload()">
                    <i class="fa-solid fa-arrows-rotate"></i>
                </button>
                <button id="saveButton" style="display:none;" class="btn btn-primary">Save Merged Image</button>
            </div>
            <div class="row" id="finisedOutput"></div>
        </div>
    </div>
    <script>

        document.getElementById('upload').addEventListener('change', function (event) {
            var file = event.target.files[0];
            var reader = new FileReader();
            reader.onload = function (e) {
                var img = new Image();
                img.onload = function () {

                    var noOfImages = Number(document.getElementById('noOfImages').value);
                    var noOfTimes = Number(document.getElementById('noOfTimes').value);
                    var newCanvasHeight = Math.floor(img.height / noOfImages);
                    const resultCanvas = [];
                    for (let index = 0; index < noOfImages; index++) {
                        var newCanvas = document.createElement('canvas');
                        newCanvas.width = img.width;
                        newCanvas.height = newCanvasHeight;
                        resultCanvas[index] = newCanvas;
                    }

                    var finishedCanvas = createImage(img, resultCanvas, noOfTimes, noOfImages);

                    // Append the merged canvas to the body
                    for (let index = 0; index < finishedCanvas.length; index++) {
                        document.getElementById('finisedOutput').appendChild(finishedCanvas[index]);
                    }

                    // Show the save button
                    document.getElementById('saveButton').style.display = 'block';

                    // Save the merged image as a new file
                    document.getElementById('saveButton').addEventListener('click', function () {
                        for (let index = 0; index < finishedCanvas.length; index++) {
                            var canvas = finishedCanvas[index];

                            // Convert canvas to BMP using canvas-to-bmp library
                            var bmpBlob = canvasToBMP(canvas);

                            // Create a download link
                            var link = document.createElement('a');
                            link.download = `merged_image_${index + 1}.bmp`;
                            link.href = URL.createObjectURL(bmpBlob);
                            link.click();
                        }
                    });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        function createImage(img, resultCanvas, noOfTimes, noOfImages) {
            var canvas = document.getElementById('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const canvasCtx = [];
            for (let index = 0; index < resultCanvas.length; index++) {
                var newCanvasCtx = resultCanvas[index].getContext('2d');
                canvasCtx[index] = newCanvasCtx;
            }
            var newCanvasHeight = Math.floor(img.height / noOfImages);
            var originalIndex = 0;
            for (var y = 0; y < newCanvasHeight; y += noOfTimes) {
                for (let index = 0; index < canvasCtx.length; index++) {
                    var row1 = ctx.getImageData(0, originalIndex, img.width, noOfTimes);
                    canvasCtx[index].putImageData(row1, 0, y);
                    originalIndex += noOfTimes;
                }
            }
            return resultCanvas;
        }

        function canvasToBMP(canvas) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);

            // Encode as BMP
            const rowSize = Math.ceil((3 * width) / 4) * 4; // Each row is padded to a multiple of 4 bytes
            const pixelArraySize = rowSize * height;
            const fileSize = 54 + pixelArraySize;
            const buffer = new ArrayBuffer(fileSize);
            const dv = new DataView(buffer);

            // BMP Header
            dv.setUint8(0, 0x42); // B
            dv.setUint8(1, 0x4D); // M
            dv.setUint32(2, fileSize, true); // File size
            dv.setUint32(6, 0, true); // Reserved
            dv.setUint32(10, 54, true); // Offset to pixel array

            // DIB Header
            dv.setUint32(14, 40, true); // DIB Header Size
            dv.setInt32(18, width, true); // Width
            dv.setInt32(22, height, true); // Height (positive for bottom-up)
            dv.setUint16(26, 1, true); // Planes
            dv.setUint16(28, 24, true); // Bits per pixel (24-bit)
            dv.setUint32(30, 0, true); // Compression
            dv.setUint32(34, pixelArraySize, true); // Image size
            dv.setUint32(38, 2835, true); // X Pixels per meter (72 DPI)
            dv.setUint32(42, 2835, true); // Y Pixels per meter (72 DPI)
            dv.setUint32(46, 0, true); // Total colors
            dv.setUint32(50, 0, true); // Important colors

            // Pixel Array (RGB with padding for each row)
            let offset = 54;
            for (let y = height - 1; y >= 0; y--) { // Start from the bottom row for bottom-up
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    dv.setUint8(offset++, imageData.data[i + 2]); // Blue
                    dv.setUint8(offset++, imageData.data[i + 1]); // Green
                    dv.setUint8(offset++, imageData.data[i]);     // Red
                }

                // Add row padding (if any)
                const padding = rowSize - width * 3;
                for (let p = 0; p < padding; p++) {
                    dv.setUint8(offset++, 0);
                }
            }

            return new Blob([buffer], { type: 'image/bmp' });
        }




    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.1/umd/popper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/js/bootstrap.min.js"></script>
    <script src="https://kit.fontawesome.com/765de15f12.js" crossorigin="anonymous"></script>

</body>

</html>